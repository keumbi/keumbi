---
title: Java 기초 - 제어문(Control Flow Statements)
author: keumbi
date: 2022-09-01 21:20:00 +0900
categories: [Language, Java]
tags: [week3, java]
published: false
---


## Overview


## 배열이란?

- 7월 한 달 동안의 일별 최고 기온을 저장할 때 → 7월은 총 31일 → 총 31개의 변수가 필요

```java
double temperatureOfJuly1  = 28.1;
double temperatureOfJuly2  = 30.2;
...
double temperatureOfJuly31 = 32.3;
```

- 7월 한 달 동안의 일별 강수 여부를 저장할 때 → 7월은 총 31일 → 총 31개의 변수가 필요

```java
boolean isRainyJuly1  = true;
boolean isRainyJuly2  = false;
...
boolean isRainyJuly31 = false;
```

위와 같은 상황일 때, 배열 없이 단순히 변수로만 값을 저장하려면 두 상황 각각 31개의 변수를 선언해야 합니다. 그러나 배열을 사용하면 각 상황마다 단 하나의 변수만으로 데이터를 다룰 수 있습니다.

**배열이란, 동일한 타입의 값들을 하나의 묶음으로 묶은 자료 구조를 의미합니다.** 즉, 각 값들이 같은 의미를 지니면서 서로 연관성이 있을 때, 이들을 하나의 덩어리로 묶을 수 있으며, 이렇게 묶여진 값들의 집합을 배열이라고 합니다.

그림을 통해 조금 더 자세하게 이해해봅시다. 그림으로 배열을 설명하기에 앞서, 메모리의 구조를 간단하게 짚을 필요가 있습니다.

아래는 여러분이 RAM으로 알고 있는 메모리를 형상화한 그림입니다. 메모리는 아래와 같이 여러 메모리셀들로 이루어져 있으며, 각 메모리셀은 값을 저장할 수 있는 **1바이트의 메모리 공간**을 가지고 있습니다.

이 메모리 공간을 아래 그림에서는 빈칸으로 표현해두었습니다. 또한 각 메모리 셀마다 0x001a3d41과 같이 16진수로 이루어진 메모리 주소가 지정되어져 있으며, 메모리 주소는 오름차순으로 매겨져 있습니다.

그림을 살펴보면 여러분이 16진수에 대해 알지 못하더라도, 오른쪽으로 갈수록 메모리셀의 일의 자리 숫자가 1씩 증가하는 것을 확인할 수 있습니다.

> 여러분은 16진수에 대해서 자세히 알 필요가 없습니다. 여기에서 여러분이 메모리 구조를 간단하게 훑어보는 이유는 지금부터 배울 배열에 대해 조금 더 명확하게 학습하기 위함이지, 컴퓨터 공학에서의 메모리 구조 그 자체를 배우기 위함이 아닙니다. 따라서, 여기에서는 “메모리는 아래의 그림처럼 간략화해서 표현할 수 있으며, 각 메모리 셀들의 주소가 오름차순으로 이루어져 있구나” 정도로 이해해주시면 충분합니다.자, 이제 변수를 개별적으로 선언하여 7월 한 달 동안의 일별 최고 기온을 저장하는 경우를 살펴봅시다. 이 경우, 각 변수는 개별적으로 선언된 변수이므로 메모리 공간 상에 흩어져서 개별적으로 존재하게 됩니다.


```
double temperatureOfJuly1  = 28.1;
double temperatureOfJuly2  = 30.2;
...
double temperatureOfJuly31 = 32.3;
```

> 참고로, 위 그림에서 각 값이 차지하는 공간이 0x001a3d41 ~ 0x001a3d48과 같이 8바이트 단위인 이유는 각 값이 크기가 8바이트인 double형이기 때문입니다.


그러나 배열을 사용하여 값을 저장하는 경우, 아래와 같이 메모리 공간 상에 연속적으로 값들이 모여서 저장됩니다.

> 배열의 선언과 초기화 방법은 이어지는 컨텐츠에서 학습할 예정이니, 여기에서는 가볍게 훑어보고 넘어가주시기 바랍니다. 지금은 딱 아래와 같이만 이해해주시면 충분합니다.

> ”배열을 선언하고 초기화하는 방법은 아직 모르겠지만, 어쨌든 배열에 값을 저장하면 아래 그림과 같이 값들이 서로 모여서 저장되는구나!”
> ”자세히는 모르겠지만 중괄호(`{}`)를 통해 값들을 묶을 수 있구나!”


```
double[] temperatureOfJuly = { 27.4, 30.1, ..., 31.8 };
```

위 그림을 통해 알 수 있듯, 배열을 통해 값들을 묶어서 저장한다는 것은 메모리 공간 상에 물리적으로 값들을 모아서 저장하는 것을 의미합니다.

배열과 관련하여 중요한 개념을 알려드리겠습니다. 위 그림에서 배열이 가진 각 값들을 배열의 **요소(element)**라고 합니다. 그리고, 배열의 각 요소는 0에서부터 시작하는 번호를 부여받는데, 이처럼 배열의 각 요소가 부여받는 순번을 **인덱스(index)**라고 합니다. 예를 들어, 배열의 맨 첫 번째 요소의 인덱스는 0이며, 두 번째 인덱스는 1, 마지막 요소인 31번째 요소의 인덱스는 30이 됩니다.

이제 여러분은 배열이 무엇인지에 대한 개념적인 학습을 마쳤습니다. 다시 한 번 언급하지만 배열을 선언하고 초기화하는 방법, 그리고 배열 요소의 값을 참조하는 방법에 대해서는 다음 콘텐츠에서부터 다룰 예정입니다. 이 콘텐츠에서는 개념적인 부분에 한해서만 이해해주시기 바랍니다.

## 배열의 차원이란?

배열을 사용할 때, 1차원 배열과 2차원 배열을 흔히 사용합니다. 필요에 따라서는 3차원 배열과 4차원 배열도 만들어 사용할 수 있지만, 사용 빈도는 1차원 배열과 2차원 배열에 비해 현저히 드뭅니다.

배열과 관련하여 언급되는 ‘차원’이라는 것은 **배열이 중첩된 정도**를 의미합니다. 즉, 배열이 중첩되었다 함은, **배열의 요소가 또 다른 배열인 경우**를 의미합니다. 자주 사용하는 1차원 배열과 2차원 배열에 대해서만 설명하겠습니다. 참고로, 2차원 이상의 배열을 다차원 배열이라고 합니다.

- **1차원 배열 : 배열이 중첩이 없는 경우 = 배열의 요소가 배열이 아닌 경우**
  - 예 : { 1, 2, 3, 4 }
    - 배열의 각 요소는 1, 2, 3, 4로 모두 정수형의 값입니다.
- **2차원 배열 : 배열이 한 번 중첩된 경우 = 배열의 요소가 배열인 경우**
  - 예 : { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } }
    - 배열의 각 요소로 배열이 들어가 있습니다.

자, 이제 본격적으로 배열을 학습하기 위해 필요한 개념들을 모두 학습하였습니다. 이제 다음 콘텐츠에서부터는 지금까지 학습한 내용들을 기반으로 배열을 어떻게 사용할 수 있는지에 대해 배워봅시다.

## **1차원 배열**

> 배열을 선언하고 생성하는 방법에는 여러 가지 방법이 존재합니다. 하지만 모든 방법을 여러분들이 다 알 필요는 없습니다. 이 콘텐츠에서는 여러분들이 학습하고 사용하기에 간편한 방법만을 골라서 정리하였습니다.


## **1차원 배열의 선언과 초기화**

1차원 배열은 가장 일반적인 배열의 형태로, 배열의 요소가 배열이 아닌 배열을 의미합니다. 1차원 배열을 선언할 때에는 다음과 같이 타입 뒤에 대괄호를 붙여서 선언하고 초기화할 수 있습니다.

```
double[] temperatureOfJuly;
temperatureOfJuly = new double[31];
```

위의 예제가 실행되면 내부적으로 아래와 같은 동작이 이루어집니다.

1. `double[] temperatureOfJuly;`
  - 배열을 가리킬 참조 변수 `temperatureOfJuly`를 선언합니다.
  - 참조 변수에 대한 설명은 아래에서 하도록 하겠습니다.
2. `new double[31];`
  - 총 31개의 `double`형 값을 저장할 수 있는 배열이 생성됩니다.
  - 이 때, 배열의 모든 요소는 `double`형의 기본값인 0.0으로 초기화되어져 있습니다.
3. `temperatureOfJuly = new double[31];`
  - 대입 연산자(`=`)에 의해 **생성된 배열 첫 번째 요소의 주소값**이 참조 변수 `temperatureOfJuly`에 할당됩니다.
  - 이제 참조 변수 `temperatureOfJuly`는 배열의 맨 첫 번째 요소를 가리키게 됩니다.

### 왜 `temperatureOfJuly`는 참조 변수여야만 할까요?

자바에서 배열은 참조 타입에 해당합니다. 따라서 `double[]`이라는 배열 선언 문법으로 선언한 `temperatureOfJuly`는 선언 이후에 생성될 배열의 주소값을 담을 참조 변수가 됩니다.

잠시 [타입] 콘텐츠에서 학습했던 내용을 복습해봅시다. 자바의 타입은 기본 타입과 참조 타입으로 나뉜다고 했습니다.

- **기본 타입**의 값을 변수에 할당하면 해당 변수에는 **실제 값**이 저장됩니다.
- **참조 타입**의 값을 변수에 할당하면 해당 변수에는 **주소값**이 저장됩니다.

변수를 선언한다는 것은 어떤 값을 저장할 메모리 공간을 확보하고, 해당 메모리 공간에 이름을 붙이는 것을 의미합니다.

`int`형, `double`형과 같은 **기본 타입의 경우, 기본 타입의 값을 저장할 변수를 선언하는 시점에 얼마 만큼의 메모리 공간을 확보해야 하는지 컴퓨터가 알 수 있습니다.** 변수 이름 앞에 타입이 붙어 있으며, 각 타입 별로 크기가 정해져 있기 때문입니다.

```
double temperature;

// 컴퓨터 : 'double형이니 8byte의 메모리를 확보하면 되겠군.'
```

그러나, 참조 타입의 경우는 다릅니다.

`double[] temperatureOfJuly;`와 같이 **배열을 선언하는 시점에 배열이 몇개의 요소를 가질지 컴퓨터는 알 수 없습니다.** 따라서 배열을 선언하면, 이후에 생성될 배열의 주소값을 담을 메모리 공간만이 확보됩니다. 이후 배열이 생성되고 난 다음에 해당 배열의 시작 주소값이 참조 변수에 할당됩니다.

```
double[] temperatureOfJuly;

// 컴퓨터 : '타입에 []가 붙었으니 배열 참조 변수군. 배열의 요소가 몇 개일지 모르니 어딘가에 배열을
//         먼저 생성한 다음, 생성된 배열의 시작 주소를 temperatureOfJuly에 메모해두자'
```

참고로, 선언과 초기화는 아래와 같이 하나의 문장으로 작성할 수도 있습니다. 결과는 위의 예제 코드와 같습니다.

```
double[] temperatureOfJuly = new double[31];
```

여기까지 배열을 선언하고 초기화하는 방법을 알아보았습니다.

그러나, 위의 방법으로 생성한 배열의 요소는 모두 `double`형의 기본값인 0.0으로 초기화되어져 있는 상태입니다. 27.4, 30.1와 같은 실제 값을 넣어서 초기화하려면 어떻게 해야 할까요? 아래와 같이 하면 됩니다.

```
double[] temperatureOfJuly = new double[] { 27.4, 30.1, 31.1, 32.4, ..., 31.8 };

// 선언과 초기화를 하나의 문장으로 할 때에 한해 new double[]을 생략할 수 있습니다.
double[] temperatureOfJuly = { 27.4, 30.1, 31.1, 32.4, ..., 31.8 };
```

### 정리

아래 코드가 실행되면 어떤 일이 일어나는지 정리해보겠습니다.

```
double[] temperatureOfJuly = { 27.4, 30.1, 31.1, 32.4, ..., 31.8 };
```

1. 참조 변수 `temperatureOfJuly`가 선언됩니다.
2. 배열이 생성되고 중괄호(`{}`) 내의 값으로 배열 요소들의 값이 초기화됩니다.
3. 생성된 배열의 첫 번째 요소의 주소값이 참조 변수 `temperatureOfJuly`에 할당됩니다.

## 값 접근하기

자 이제 여러분은 배열을 선언하고 원하는 값을 넣는 방법까지 배웠습니다. 이제는 배열에 넣은 값을 사용하는 방법을 배워봅시다.

**배열 내 특정 요소에 할당되어져 있는 값에 접근하려면 배열 참조 변수의 이름과 배열의 인덱스를 활용하면 됩니다.** 즉, **`배열_참조_변수_이름[인덱스]`로 배열의 요소에 접근할 수 있습니다.**

예를 들어 아래와 같이 배열을 선언한 경우,

```
double[] temperatureOfJuly = { 27.4, 30.1, 31.1, 32.4, ..., 31.8 };
```

- 첫 번째 요소는 `temperatureOfJuly[0]`으로 접근할 수 있으며, 값은 27.4입니다.
- 두 번째 요소는 `temperatureOfJuly[1]`로 접근할 수 있으며, 값은 30.1입니다.
- 세 번째 요소는 `temperatureOfJuly[2]`로 접근할 수 있으며, 값은 31.1입니다.
- 네 번째 요소는 `temperatureOfJuly[3]`으로 접근할 수 있으며, 값은 32.4입니다.
- 마지막 요소는 `temperatureOfJuly[30]`으로 접근할 수 있으며, 값은 31.8입니다.

인덱스로 값에 접근할 수 있는 원리를 간단하게 설명하겠습니다. 위에서 배열의 선언과 초기화를 설명할 때, 배열이 생성되고 나면 **배열 첫 번째 요소의 주소값이 참조 변수 `temperatureOfJuly`에 할당된다**고 했습니다. 그리고, **배열의 각 요소는 0부터 시작하는 인덱스를 가진다**고 했습니다.

원리는 간단합니다. `배열_참조_변수_이름[인덱스]`라고 입력하면 **참조 변수가 가진 배열 첫 번째 요소의 주소값에 '인덱스 * 요소의 크기'를 더하여 얻을 수 있는 수를 주소로 가진 요소의 값을 읽어옵니다.**

- `temperatureOfJuly[0]`
  - `temperatureOfJuly`가 저장하고 있는 주소값 0x001a3d41 + 인덱스 `0` * 요소의 크기 8byte = **0x001a3d41** → **27.4**
- `temperatureOfJuly[1]`
  - `temperatureOfJuly`가 저장하고 있는 주소값 0x001a3d41 + 인덱스 `1` * 요소의 크기 8byte = **0x001a3d49** → **30.1**
- `temperatureOfJuly[2]`
  - `temperatureOfJuly`가 저장하고 있는 주소값 0x001a3d41 + 인덱스 `2` * 요소의 크기 8byte = **0x001a3d51** → **31.1**
- `temperatureOfJuly[3]`
  - `temperatureOfJuly`가 저장하고 있는 주소값 0x001a3d41 + 인덱스 `3` * 요소의 크기 8byte = **0x001a3d59** → **32.4**
- `temperatureOfJuly[30]`
  - `temperatureOfJuly`가 저장하고 있는 주소값 0x001a3d41 + 인덱스 `30` * 요소의 크기 8byte = **0x001a3e31** → **31.8**

## 배열의 길이

배열이 가진 요소의 개수를 배열의 **길이** 또는 **크기**라고 합니다. 배열의 길이는 `배열_참조_변수_이름.length`로 얻을 수 있습니다.

```
double[] temperatureOfJuly = new double[31];

System.out.println(temperatureOfJuly.length); // 31
```

배열의 길이와 인덱스의 관계를 살펴봅시다. 인덱스는 0부터 시작하므로, 배열의 길이가 31이라면 배열 마지막 요소의 인덱스는 30이 됩니다. 즉, **배열의 길이 - 1**이 배열 마지막 요소의 인덱스가 됩니다.

---

여기까지 1차원 배열을 선언하고, 초기화하고, 배열 요소의 값에 접근하는 방법을 살펴보았습니다. 아래의 예제를 직접 풀어보면서 이해도를 점검해보세요.

- 배열 참조 변수 `num`을 선언하고, `int`형의 값 1, 2, 3, 4, 5를 요소로 가지는 배열을 생성하여 `num`에 할당해보세요.
- 배열 참조 변수 `favoriteThings`를 선언하고, 자신이 가장 좋아하는 것들을 요소로 가지는 문자열 배열을 생성해 `favoriteThings`에 할당해보세요.
- 배열 참조 변수 `isRainy`를 선언하고, 앞으로 일주일 동안 비가 올지 안올지의 여부를 요소로 가지는 `boolean`형 배열을 생성해 `isRainy`에 할당해보세요.

참고로, 배열의 요소는 `Arrays.toString()` 메서드를 통해 쉽게 확인할 수 있습니다. 해당 메서드의 사용 방법을 검색해보고 직접 활용해보세요.

## Reference
